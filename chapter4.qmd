---
title: "The Edition"
---

This is the fourth chapter of my Quarto book.

```{r setup, include=FALSE}
# Load the xml2 package
library(xml2)
```

::: {.panel-tabset}

## Unedited Mess

```{r results='asis'}
# Read the XML content
xml_file <- read_xml("data/T-E.xml")

# Extract the <l> and <cb> elements inside the <text> element
lines <- xml_find_all(xml_file, "//text//l | //text//cb")

# Initialize an empty list to store the processed lines
processed_lines <- list()

# Function to process each <l> element
process_line <- function(line) {
  # Find all <choice> elements within the line
  choices <- xml_find_all(line, ".//choice")
  for (choice in choices) {
    # Extract the text from the <orig> tag
    orig_text <- xml_text(xml_find_first(choice, ".//orig"))
    # Remove the <choice> element and replace it with the text from the <orig> tag
    xml_set_text(choice, orig_text)
  }
  
  # Now we want to remove any <reg> elements entirely
  reg_elements <- xml_find_all(line, ".//reg")
  xml_remove(reg_elements)
  
  # Replace <lb/> tags with HTML line break
  lb_elements <- xml_find_all(line, ".//lb")
  for (lb in lb_elements) {
    xml_set_text(lb, "")
  }
  
  # Get the text of the line and wrap in a div with line-height control
  line_text <- sprintf("<div style='line-height: 1.2;'>%s</div>", as.character(line))
  
  # Return the processed text of the line
  return(line_text)
}

# Process each line and wrap with <div class='column-break'> at each <cb/>
for (line in lines) {
  if (xml_name(line) == "cb") {
    # Add a closing </div> for the previous column and an opening <div> for the new column
    processed_lines <- c(processed_lines, "</div>", "<div class='column-break'>")
  } else {
    # Process the line and add it to the current column
    processed_lines <- c(processed_lines, process_line(line))
  }
}

# Wrap the entire content with <div class='column-break'> tags
formatted_text <- paste(c("<div class='column-break'>", processed_lines, "</div>"), collapse = "\n")

# Print the formatted text content as a block of text, preserving line breaks
cat(formatted_text, sep = "")
```

## Expanded Abbreviations Mess

```{r results='asis'}
# Read the XML content
xml_file <- read_xml("data/T-E.xml")

# Extract the <l> and <cb> elements inside the <text> element
lines <- xml_find_all(xml_file, "//text//l | //text//cb")

# Initialize an empty list to store the processed lines
processed_lines <- list()

# Function to process each <l> element
process_line <- function(line) {
  # Find all <choice> elements within the line
  choices <- xml_find_all(line, ".//choice")
  for (choice in choices) {
    # Check if the <choice> element contains <abbr> and <expan>
    abbr_exists <- xml_find_first(choice, ".//abbr")
    expan_exists <- xml_find_first(choice, ".//expan")
    
    if (!is.na(abbr_exists) && !is.na(expan_exists)) {
      # If <abbr> and <expan> tags exist, extract only the <reg> text from <expan>
      reg_text <- xml_text(xml_find_first(choice, ".//expan/reg"))
      xml_set_text(choice, reg_text)
    } else {
      # For non-abbreviation choices, keep original behavior
      orig_text <- xml_text(xml_find_first(choice, ".//orig"))
      xml_set_text(choice, orig_text)
    }
  }
  
  # Now we want to remove any <reg> elements entirely
  reg_elements <- xml_find_all(line, ".//reg")
  xml_remove(reg_elements)
  
  # Replace <lb/> tags with HTML line break
  lb_elements <- xml_find_all(line, ".//lb")
  for (lb in lb_elements) {
    xml_set_text(lb, "")
  }
  
  # Get the text of the line and wrap in a div with line-height control
  line_text <- sprintf("<div style='line-height: 1.2;'>%s</div>", as.character(line))
  
  # Return the processed text of the line
  return(line_text)
}

# Process each line and wrap with <div class='column-break'> at each <cb/>
for (line in lines) {
  if (xml_name(line) == "cb") {
    # Add a closing </div> for the previous column and an opening <div> for the new column
    processed_lines <- c(processed_lines, "</div>", "<div class='column-break'>")
  } else {
    # Process the line and add it to the current column
    processed_lines <- c(processed_lines, process_line(line))
  }
}

# Wrap the entire content with <div class='column-break'> tags
formatted_text <- paste(c("<div class='column-break'>", processed_lines, "</div>"), collapse = "\n")

# Print the formatted text content as a block of text, preserving line breaks
cat(formatted_text, sep = "")
```

## Editor's Choice Mess

```{r results='asis'}
# Read the XML content
xml_file <- read_xml("data/T-E.xml")

# Extract the <l> and <cb> elements inside the <text> element
lines <- xml_find_all(xml_file, "//text//l | //text//cb")

# Initialize an empty list to store the processed lines
processed_lines <- list()

# Function to process each <l> element
process_line <- function(line) {
  # Find all <choice> elements within the line
  choices <- xml_find_all(line, ".//choice")
  for (choice in choices) {
    # Extract the text from the <reg> tag
    reg_text <- xml_text(xml_find_first(choice, ".//reg"))
    # Replace the <choice> element with the text from the <reg> tag
    xml_set_text(choice, reg_text)
  }
  
  # Now we want to remove any <orig> elements entirely
  orig_elements <- xml_find_all(line, ".//orig")
  xml_remove(orig_elements)
  
  # Replace <lb/> tags with HTML line break
  lb_elements <- xml_find_all(line, ".//lb")
  for (lb in lb_elements) {
    xml_set_text(lb, "")
  }
  
  # Get the text of the line and wrap in a div with line-height control
  line_text <- sprintf("<div style='line-height: 1.2;'>%s</div>", as.character(line))
  
  # Return the processed text of the line
  return(line_text)
}

# Process each line and wrap with <div class='column-break'> at each <cb/>
for (line in lines) {
  if (xml_name(line) == "cb") {
    # Add a closing </div> for the previous column and an opening <div> for the new column
    processed_lines <- c(processed_lines, "</div>", "<div class='column-break'>")
  } else {
    # Process the line and add it to the current column
    processed_lines <- c(processed_lines, process_line(line))
  }
}

# Wrap the entire content with <div class='column-break'> tags
formatted_text <- paste(c("<div class='column-break'>", processed_lines, "</div>"), collapse = "\n")

# Print the formatted text content as a block of text, preserving line breaks
cat(formatted_text, sep = "")
```

:::
